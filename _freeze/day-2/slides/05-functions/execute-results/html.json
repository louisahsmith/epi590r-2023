{
  "hash": "636e97f70587e3f757de4c650a5dd99b",
  "result": {
    "markdown": "---\ntitle: \"Functions\"\nformat: revealjs\nexecute: \n  eval: true\n  echo: true\n---\n\n\n## Functions in R\n\nI've been denoting functions with parentheses: `func()`\n\nWe've seen functions such as:\n\n-   `mean()`\n-   `tbl_summary()`\n-   `init()`\n-   `create_github_token`\n\nFunctions take **arguments** and return **values**\n\n## Looking inside a function\n\nIf you want to see the code within a function, you can just type its name without the parentheses:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::create_github_token\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (scopes = c(\"repo\", \"user\", \"gist\", \"workflow\"), description = \"DESCRIBE THE TOKEN'S USE CASE\", \n    host = NULL) \n{\n    scopes <- glue_collapse(scopes, \",\")\n    host <- get_hosturl(host %||% default_api_url())\n    url <- glue(\"{host}/settings/tokens/new?scopes={scopes}&description={description}\")\n    withr::defer(view_url(url))\n    hint <- code_hint_with_host(\"gitcreds::gitcreds_set\", host)\n    ui_todo(\"\\n    Call {ui_code(hint)} to register this token in the \\\\\\n    local Git credential store\\n    It is also a great idea to store this token in any password-management \\\\\\n    software that you use\")\n    invisible()\n}\n<bytecode: 0x104c98aa0>\n<environment: namespace:usethis>\n```\n\n\n:::\n:::\n\n\n## Structure of a function\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunc <- function()\n```\n:::\n\n\nYou can name your function like you do any other object\n\n-   Just avoid names of existing functions\n\n\n## Structure of a function\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunc <- function(arg1, \n                 arg2 = default_val)\n}\n```\n:::\n\n\nWhat objects/values do you need to make your function work?\n\n-   You can give them default values to use if the user doesn't specify others\n\n## Structure of a function\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunc <- function(arg1, \n                 arg2 = default_val) {\n\n} \n```\n:::\n\n\nEverything else goes within curly braces\n\n-   Code in here will essentially look like any other R code, using any inputs to your functions\n\n\n## Structure of a function\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunc <- function(arg1, \n                 arg2 = default_val) {\n  new_val <- # do something with args \n} \n```\n:::\n\n\n-   One thing you'll likely want to do is make new objects along the way\n\n-   These aren't saved to your environment (i.e., you won't see them in the upper-right window) when you run the function\n\n-   You can think of them as being stored in a temporary environment within the function\n\n\n## Structure of a function\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunc <- function(arg1, \n                 arg2 = default_val) {\n  new_val <- # do something with args\n  return(new_val)\n} \n```\n:::\n\n\nReturn something new that the code has produced\n\n-   The `return()` statement is actually optional. If you don't put it, it will return the last object in the code. When you're starting out, it's safer to always explicitly write out what you want to return.\n\n\n## Example: a new function for the mean\n\nLet's say we are not satisfied with the `mean()` function and want to write our own.\n\nHere's the general structure we'll start with.\n\n::: larger-code\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_mean <- function() {\n\n}\n```\n:::\n\n:::\n\n## New mean: arguments\n\nWe'll want to take the mean of a vector of numbers.\n\nIt will help to make an example of such a vector to think about what the input might look like, and to test the function. We'll call it `x`:\n\n::: larger-code\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 3, 5, 7, 9)\n```\n:::\n\n:::\n\nWe can add `x` as an argument to our function:\n\n::: larger-code\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_mean <- function(x) {\n\n}\n```\n:::\n\n:::\n\n## New mean: function body\n\nLet's think about how we calculate a mean in math, and then translate it into code:\n\n$$\\bar{x} = \\frac{1}{n}\\sum_{i = 1}^n x_i$$\n\nSo we need to sum the elements of `x` together, and then divide by the number of elements.\n\n## \n\nWe can use the functions `sum()` and `length()` to help us.\n\nWe'll write the code with our test vector first, before inserting it into the function:\n\n::: larger-code\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- length(x)\nsum(x) / n\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n:::\n\n:::\n\n## New mean: function body\n\nOur code seems to be doing what we want, so let's insert it. To be explicit, I've stored the answer (within the function) as `mean_val`, then returned that value.\n\n::: larger-code\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_mean <- function(x) {\n  n <- length(x)\n  mean_val <- sum(x) / n\n  return(mean_val)\n}\n```\n:::\n\n:::\n\n## Testing a function\n\nLet's plug in the vector that we created to test it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_mean(x = x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n:::\n\n\nAnd then try another one we create on the spot:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_mean(x = c(100, 200, 300))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 200\n```\n\n\n:::\n:::\n\n\n## Adding another argument\n\nLet's say we plan to be using our `new_mean()` function to calculate proportions (i.e., the mean of a binary variable). Sometimes we'll want to report them as as percentage by multiplying the proportion by 100.\n\nLet's name our new function `prop()`. We'll use the same structure as we did with `new_mean()`.\n\n::: larger-code\n\n::: {.cell}\n\n```{.r .cell-code}\nprop <- function(x) {\n  n <- length(x)\n  mean_val <- sum(x) / n\n  return(mean_val)\n}\n```\n:::\n\n:::\n\n## Testing the code\n\nNow we'll want to test on a vector of 1's and 0's.\n\n::: larger-code\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(0, 1, 1)\n```\n:::\n\n:::\n\nTo calculate the proportion and turn it into a percentage, we'll just multiply the mean by 100.\n\n::: larger-code\n\n::: {.cell}\n\n```{.r .cell-code}\nmultiplier <- 100\nmultiplier * sum(x) / length(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 66.66667\n```\n\n\n:::\n:::\n\n:::\n\n## Testing the code\n\nWe want to give users the option to choose between a proportion and a percentage. So we'll add an argument `multiplier`. When we want to just return the proportion, we can just set `multiplier` to be 1.\n\n::: larger-code\n\n::: {.cell}\n\n```{.r .cell-code}\nmultiplier <- 1\nmultiplier * sum(x) / length(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.6666667\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmultiplier <- 100\nmultiplier * sum(x) / length(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 66.66667\n```\n\n\n:::\n:::\n\n:::\n\n## Adding another argument\n\nIf we add `multiplier` as an argument, we can refer to it in the function body.\n\n::: larger-code\n\n::: {.cell}\n\n```{.r .cell-code}\nprop <- function(x, multiplier) {\n  n <- length(x)\n  mean_val <- multiplier * sum(x) / n\n  return(mean_val)\n}\n```\n:::\n\n:::\n\n## Adding another argument\n\nNow we can test:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprop(x = c(1, 0, 1, 0), multiplier = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprop(x = c(1, 0, 1, 0), multiplier = 100)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 50\n```\n\n\n:::\n:::\n\n\n\n## Making a default argument\n\nSince we don't want users to have to specify `multiplier = 1` every time they just want a proportion, we can set it as a **default**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprop <- function(x, multiplier = 1) {\n  n <- length(x)\n  mean_val <- multiplier * sum(x) / n\n  return(mean_val)\n}\n```\n:::\n\n\nNow we only need to specify that argument if we want a percentage.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprop(x = c(0, 1, 1, 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.75\n```\n\n\n:::\n\n```{.r .cell-code}\nprop(x = c(0, 1, 1, 1), multiplier = 100)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 75\n```\n\n\n:::\n:::\n\n\n## Caveats\n\n-   This is obviously not the best way to write this function!\n\n-   For example, it will still work if `x = c(123, 593, -192)`.... but it certainly won't give you a proportion or a percentage!\n\n-   We could also put `multiplier =` *any number*, and we'll just be multiplying the answer by that number -- this is essentially meaningless.\n\n-   We also haven't done any checking to see whether the user is even entering numbers! We could put in better error messages so users don't just get an R default error message if they do something wrong.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprop(x = c(\"blah\", \"blah\", \"blah\"))\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in sum(x): invalid 'type' (character) of argument\n```\n\n\n:::\n:::\n\n\n## Exercises\n\nCreate some functions!\n\nCreate an R script in your project called `functions.R` to save your work!",
    "supporting": [
      "05-functions_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}